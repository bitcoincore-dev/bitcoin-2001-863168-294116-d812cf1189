#include <algorithm>
#include <boost/core/explicit_operator_bool.hpp>
#include <boost/optional/optional.hpp>
#include <capnp/blob.h>
#include <capnp/schema-parser.h>
#include <capnp/schema.capnp.h>
#include <capnp/schema.h>
#include <cctype>
#include <fstream>
#include <kj/common.h>
#include <kj/string.h>
#include <map>
#include <memory>
#include <sstream>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#define PROXY_BIN "interface/capnp/proxy-codegen"
#define PROXY_DECL "interface/capnp/proxy.h"
#define PROXY_IMPL "interface/capnp/proxy-impl.h"

static constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp
static constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp
static constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp
static constexpr uint64_t ASYNC_ANNOTATION_ID = 0x82691dae52a0a145ull;     // From proxy.capnp
static constexpr uint64_t NAME_ANNOTATION_ID = 0xb594888f63f4dbb9ull;      // From proxy.capnp
static constexpr uint64_t SKIP_ANNOTATION_ID = 0x824c08b82695d8ddull;      // From proxy.capnp

template <typename Reader>
boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)
{
    for (const auto& annotation : reader.getAnnotations()) {
        if (annotation.getId() == id) return annotation.getValue();
    }
    return {};
}

using CharSlice = kj::ArrayPtr<const char>;

// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.
template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>
OutputStream& operator<<(OutputStream& os, const Array& array)
{
    os.write(array.begin(), array.size());
    return os;
}

struct Format
{
    template <typename Value>
    Format& operator<<(Value&& value)
    {
        m_os << value;
        return *this;
    }
    operator std::string() { return m_os.str(); }
    std::ostringstream m_os;
};

std::string Cap(kj::StringPtr str)
{
    std::string result = str;
    if (!result.empty()) result[0] = toupper(result[0]);
    return result;
}

bool PrimitiveType(const ::capnp::Type& type)
{
    return type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||
           type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||
           type.isFloat64();
}

bool InitType(const ::capnp::Type& type) { return !PrimitiveType(type) && !type.isInterface(); }

void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)
{
    capnp::SchemaParser parser;
    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});

    const std::string stem = output_stem;
    std::ofstream cpp(stem + ".capnp.proxy.c++");
    cpp << "// Generated by " PROXY_BIN " from " << input_schema << "\n\n";
    cpp << "#include <" << stem << ".capnp.proxy-impl.h>\n";
    cpp << "#include <" << PROXY_IMPL << ">\n\n";
    cpp << "namespace interface {\n";
    cpp << "namespace capnp {\n";

    std::string guard = stem;
    std::transform(guard.begin(), guard.end(), guard.begin(),
        [](unsigned char c) { return std::isalnum(c) ? std::toupper(c) : '_'; });

    std::ofstream impl(stem + ".capnp.proxy-impl.h");
    impl << "// Generated by " PROXY_BIN " from " << input_schema << "\n\n";
    impl << "#ifndef " << guard << "_CAPNP_PROXY_IMPL_H\n";
    impl << "#define " << guard << "_CAPNP_PROXY_IMPL_H\n\n";
    impl << "#include <" << stem << ".capnp.proxy.h>\n";
    impl << "#include <" << stem << "-impl.h>\n\n";
    impl << "namespace interface {\n";
    impl << "namespace capnp {\n";

    std::ofstream h(stem + ".capnp.proxy.h");
    h << "// Generated by " PROXY_BIN " from " << input_schema << "\n\n";
    h << "#ifndef " << guard << "_CAPNP_PROXY_H\n";
    h << "#define " << guard << "_CAPNP_PROXY_H\n\n";
    h << "#include <" << stem << ".h>\n";
    h << "#include <" << PROXY_DECL << ">\n\n";
    h << "namespace interface {\n";
    h << "namespace capnp {\n";

    kj::StringPtr message_namespace;
    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {
        message_namespace = value->getText();
    }

    auto print_setter = [&](std::ostream& os, const std::string& builder, const ::capnp::StructSchema::Field& field) {
        if (field.getType().isInterface()) {
            const auto& interface = field.getType().asInterface();
            os << "static_cast<void (" << builder << "::*)(" << message_namespace
               << "::" << interface.getShortDisplayName() << "::Client&&)>(";
        }
        os << "&" << builder << "::";
        os << (InitType(field.getType()) ? "init" : "set");
        os << Cap(field.getProto().getName());
        if (field.getType().isInterface()) {
            os << ")";
        }
    };

    for (const auto& node_nested : file_schema.getProto().getNestedNodes()) {
        kj::StringPtr node_name = node_nested.getName();
        const auto& node = file_schema.getNested(node_name);
        kj::StringPtr proxied_class_type;
        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {
            proxied_class_type = proxy->getText();
        }
        if (node.getProto().isStruct()) {
            const auto& struc = node.asStruct();
            h << "template<>\n";
            h << "struct ProxyStruct<" << message_namespace << "::" << node_name << ">\n";
            h << "{\n";
            h << "    using Struct = " << message_namespace << "::" << node_name << ";\n";
            size_t i = 0;
            for (const auto& field : struc.getFields()) {
                auto field_name = field.getProto().getName();
                h << "    static auto get" << Cap(field_name) << "() -> AUTO_RETURN(MakeAccessor(&Struct::Reader::get"
                  << Cap(field_name) << ", ";
                print_setter(h, "Struct::Builder", field);
                h << ", ";
                if (!PrimitiveType(field.getType())) {
                    h << "&Struct::Reader::has" << Cap(field_name);
                } else {
                    h << "nullptr";
                }
                h << ", nullptr, nullptr, nullptr))\n";

                if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {
                    continue;
                }
                h << "    static auto get(std::integral_constant<size_t, " << i << ">) -> AUTO_RETURN(get"
                  << Cap(field_name) << "())\n";
                ++i;
            }
            h << "    static constexpr size_t fields = " << i << ";\n";
            h << "};\n";

            if (proxied_class_type.size()) {
                impl << "template<>\n";
                impl << "class ProxyType<" << proxied_class_type << ">\n";
                impl << "{\n";
                impl << "public:\n";
                impl << "    using Struct = " << message_namespace << "::" << node_name << ";\n";
                size_t i = 0;
                for (const auto& field : struc.getFields()) {
                    if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {
                        continue;
                    }
                    auto field_name = field.getProto().getName();
                    auto member_name = field_name;
                    if (auto name = GetAnnotation(field.getProto(), NAME_ANNOTATION_ID)) {
                        member_name = name->getText();
                    }
                    impl << "    static auto get(std::integral_constant<size_t, " << i << ">) -> AUTO_RETURN("
                         << "&" << proxied_class_type << "::" << member_name << ")\n";
                    ++i;
                }
                impl << "    static constexpr size_t fields = " << i << ";\n";
                impl << "};\n";
            }
        }

        if (proxied_class_type.size() && node.getProto().isInterface()) {
            const auto& interface = node.asInterface();

            std::ostringstream client;
            client << "template<>\nclass ProxyClient<" << message_namespace << "::" << node_name << "> : ";
            client << "public ProxyClientCustom<" << message_namespace << "::" << node_name << ", "
                   << proxied_class_type << "> {\n";
            client << "public:\n";
            client << "    using Base = ProxyClientCustom<" << message_namespace << "::" << node_name << ", "
                   << proxied_class_type << ">;\n";
            client << "    using Base::Base;\n";

            std::ostringstream server;
            server << "template<>\nclass ProxyServer<" << message_namespace << "::" << node_name << "> : public "
                   << "ProxyServerCustom<" << message_namespace << "::" << node_name << ", " << proxied_class_type
                   << ">";
            server << "\n{\npublic:\n";
            server << "    using Base = ProxyServerCustom<" << message_namespace << "::" << node_name << ", "
                   << proxied_class_type << ">;\n";
            server << "    using Base::Base;\n";

            std::ostringstream methods;

            for (const auto& method : interface.getMethods()) {
                kj::StringPtr method_name = method.getProto().getName();
                kj::StringPtr proxied_method_name = method_name;
                if (auto name = GetAnnotation(method.getProto(), NAME_ANNOTATION_ID)) {
                    proxied_method_name = name->getText();
                }
                bool server_async = false;
                if (auto async = GetAnnotation(method.getProto(), ASYNC_ANNOTATION_ID)) {
                    server_async = true;
                }
                if (!proxied_class_type.size()) {
                    continue;
                }

                const std::string method_prefix = Format() << message_namespace << "::" << node_name
                                                           << "::" << Cap(method_name);

                struct Field
                {
                    boost::optional<::capnp::StructSchema::Field> param;
                    boost::optional<::capnp::StructSchema::Field> result;
                    int args = 0;
                    bool retval = false;
                    bool has = false;
                    bool want = false;
                    bool skip = false;

                    bool hasHas() const
                    {
                        return (param && !PrimitiveType(param->getType())) ||
                               ((result && !PrimitiveType(result->getType())));
                    }
                };

                std::vector<Field> fields;
                std::map<kj::StringPtr, int> field_idx; // name -> args index
                bool has_result = false;

                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {
                    auto field_name = schema_field.getProto().getName();
                    auto inserted = field_idx.emplace(field_name, fields.size());
                    if (inserted.second) {
                        fields.emplace_back();
                    }
                    auto& field = fields[inserted.first->second];
                    (param ? field.param : field.result) = schema_field;

                    if (!param && field_name == "result") {
                        field.retval = true;
                        has_result = true;
                    }

                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {
                        field.args += value->getInt32();
                    } else if (inserted.second) {
                        if (!param && field_name == "result") {
                            field.retval = true;
                        } else if (!param && (field_name == "error" || field_name == "rpcError")) {
                            field.skip = true;
                        } else {
                            // FIXME: error and rpcError should be detected with
                            // exception annotations
                            field.args = 1;
                        }
                    }
                };

                for (const auto& schema_field : method.getParamType().getFields()) {
                    add_field(schema_field, true);
                }
                for (const auto& schema_field : method.getResultType().getFields()) {
                    add_field(schema_field, false);
                }
                for (auto& field : field_idx) {
                    auto has_field = field_idx.find("has" + Cap(field.first));
                    if (has_field != field_idx.end() && !fields[field.second].hasHas()) {
                        fields[has_field->second].skip = true;
                        fields[field.second].has = true;
                    }
                    auto want_field = field_idx.find("want" + Cap(field.first));
                    if (want_field != field_idx.end() && !fields[want_field->second].result) {
                        fields[want_field->second].skip = true;
                        fields[field.second].want = true;
                    }
                }


                auto print_accessor = [&](std::ostream& os, bool client, const Field& field) {
                    auto& input = client ? field.result : field.param;
                    auto& output = client ? field.param : field.result;
                    std::string input_reader = Format() << method_prefix << (client ? "Results" : "Params")
                                                        << "::Reader";
                    std::string output_builder = Format() << method_prefix << (client ? "Params" : "Results")
                                                          << "::Builder";
                    auto field_suffix = Cap(input ? input->getProto().getName() : output->getProto().getName());

                    os << "MakeAccessor(";
                    if (input) {
                        os << "&" << input_reader << "::get" << field_suffix;
                    } else {
                        os << "nullptr";
                    }
                    os << ", ";

                    if (output) {
                        print_setter(os, output_builder, *output);
                    } else {
                        os << "nullptr";
                    }
                    os << ", ";
                    if (input && field.has) {
                        os << "&" << input_reader << "::getHas" << field_suffix;
                    } else if (input && field.hasHas()) {
                        os << "&" << input_reader << "::has" << field_suffix;
                    } else {
                        os << "nullptr";
                    }
                    os << ", ";
                    if (output && field.has) {
                        os << "&" << output_builder << "::setHas" << field_suffix;
                    } else {
                        os << "nullptr";
                    }
                    os << ", ";
                    if (field.want) {
                        os << "&" << method_prefix << "Params::Reader::getWant" << field_suffix << ", ";
                        os << "&" << method_prefix << "Params::Builder::setWant" << field_suffix;
                    } else {
                        os << "nullptr, nullptr";
                    }
                    os << ")";
                };

                methods << "template<>\n";
                methods << "struct ProxyMethod<" << method_prefix << "Params>\n";
                methods << "{\n";
                methods << "    static constexpr auto method = &" << proxied_class_type << "::" << proxied_method_name
                        << ";\n";
                methods << "};\n\n";

                std::ostringstream client_args;
                std::ostringstream client_invoke;
                std::ostringstream server_invoke;
                int argc = 0;
                for (const auto& field : fields) {
                    if (field.skip) continue;

                    auto field_name = field.param ? field.param->getProto().getName() :
                                                    field.result ? field.result->getProto().getName() : "";

                    for (int i = 0; i < field.args; ++i) {
                        if (argc > 0) client_args << ",";
                        client_args << "M" << method.getOrdinal() << "::Param<" << argc << "> " << field_name;
                        if (field.args > 1) client_args << i;
                        ++argc;
                    }

                    client_invoke << ", MakeClientParam<" << argc << "/*DEBUG*/>(";
                    print_accessor(client_invoke, true, field);
                    if (field.retval == 1 || field.args == 1) {
                        client_invoke << ", " << field_name;
                    } else {
                        for (int i = 0; i < field.args; ++i) {
                            client_invoke << ", " << field_name << i;
                        }
                    }
                    client_invoke << ")";

                    if (field.retval || field.args > 0) {
                        server_invoke << ", ";
                        server_invoke << (field.retval ? "MakeServerFieldRet" : "MakeServerField");
                        if (!field.retval && field.args != 1) {
                            server_invoke << "<" << field.args << ">";
                        }
                        server_invoke << "(";
                        print_accessor(server_invoke, false, field);
                        server_invoke << ")";
                    }
                }

                client << "    using M" << method.getOrdinal() << " = ProxyMethodTraits<" << method_prefix
                       << "Params>;\n";
                client << "    typename M" << method.getOrdinal() << "::Result " << method_name << "("
                       << client_args.str() << ")";
                client << ";\n";
                cpp << "ProxyClient<" << message_namespace << "::" << node_name << ">::M" << method.getOrdinal()
                    << "::Result ProxyClient<" << message_namespace << "::" << node_name << ">::" << method_name << "("
                    << client_args.str() << ") {\n";
                if (has_result) {
                    // FIXME: Invoke function should just return the result directly to simplify proxy gen and get rid
                    // of need for this variable. This would also unify server & client implementations.
                    cpp << "    typename M" << method.getOrdinal() << "::Result result;\n";
                }
                cpp << "    invoke(M" << method.getOrdinal() << "(), &" << message_namespace << "::" << node_name
                    << "::Client::" << method_name << "Request, *this" << client_invoke.str() << ");\n";
                if (has_result) cpp << "    return result;\n";
                cpp << "}\n";

                server << "    kj::Promise<void> " << method_name << "(" << Cap(method_name)
                       << "Context context) override;\n";
                cpp << "kj::Promise<void> ProxyServer<" << message_namespace << "::" << node_name
                    << ">::" << method_name << "(" << Cap(method_name) << "Context context) {\n"
                                                                          "    return invokeMethod"
                    << (server_async ? "Async" : "") << "(context, &" << proxied_class_type
                    << "::" << proxied_method_name << server_invoke.str() << ");\n}\n";
            }

            client << "};\n";
            server << "};\n";
            h << "\n" << methods.str() << client.str() << "\n" << server.str() << "\n";
        }
    }

    cpp << "} // namespace capnp\n";
    cpp << "} // namespace interface\n";

    impl << "} // namespace capnp\n";
    impl << "} // namespace interface\n";
    impl << "#endif\n";

    h << "} // namespace capnp\n";
    h << "} // namespace interface\n";
    h << "#endif\n";
}

int main(int argc, char** argv)
{
    if (argc != 4) {
        fprintf(stderr, "Usage: " PROXY_BIN " INPUT_SCHEMA IMPORT_PATH OUTPUT_STEM\n");
        exit(1);
    }
    Generate(argv[1], argv[2], argv[3]);
    return 0;
}
